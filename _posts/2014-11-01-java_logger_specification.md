---
layout: post
title: java日志输出规范
category: 
date: 2014-11-01
---

日志对一个线上系统的重要性是不言而喻的，日志在某种程度上来说:是系统和程序的仪表盘，同监控一样重要。不过在现实过程中，发现很多开发人员没有理解好日志的用法，对日志的使用很随意，目的性也不是很明确。

##目的 

1、建立程序的仪表盘，反映出程序中潜在的问题、系统的瓶颈点。如经常抛异常的地方，耗时最长的调用.

2、帮助开发人员查找，定位问题.

3、一些相应的技术、业务统计.

##日志级别
>level 的定义非常的重要，需要理解和使用好每种级别

	TRACE： 比DEBUG还低的级别，一般不使用。

	DEBUG： 主要给程序员做为程序调试用。在开发过程中，调试输入，输出以及程序的内部运行过程信息。

	INFO： 主要用于记录业务的运行流程，业务日志的输出，程序的依赖调用过程等重要的运行过程信息。

	WARN： 主要用于记录程序运行过程中产生的错误信息，但是这个错误是不影响当前流程继续流转，如程序内部的告警信息、访问超时信息等。

	ERROR： 用于记录程序运行过程的异常信息，记录详细异常栈，记录会导致程序内部运行流程终止的错误信息，在产生error的地方，尽量的输出上下文相关内容，越详细越好，如当前的运行时参数，异常栈等信息，便于处理错误的同学利用详细信息排查、定位系统运行过程中的错误。

>级别顺序（由低到高）： DEBUG < INFO < WARN < ERROR

##类库的使用

统一使用 slf4j  

避免在代码中直接使用log4j 、 java util logging或 Apache Logging 等实现类，slf4j 本质是 Facade , 便于我们后期随时切换日志实现.

## 输出方式

输出异常:

	logger.error(“define message or e.getMessage()”, e);
	
输出变量跟踪信息

	logger.info("日志说明，[变量A = {} , 变量B = {}]", a, b);
	logger.info("日志说明，[变量a={}, 变量b={}, 变量c={}]", new Object[] {a, b, c});
	
或者有输出整个类的信息时

	
	logger.info("日志说明，[变量a={}, 类b={}]" , a, JSON.toJSONString(实例b));
	
*特别注意*： 由于slf4j没有提供变量、异常堆栈混合输出的接口，所以下面的几种方式将*不可能输出异常堆栈*

	
	logger.error("日志说明，[变量a={},异常堆栈e={}]", a, e);
	logger.error("日志说明，[变量a={}, 变量b={}, 异常堆栈e={}]", new Object[] {a, b, e});
	
*正确的方式*: 使用变量、异常堆栈混合输出

	logger.error(String.format("必要说明，[变量a=%s, 变量b=%s, 变量c=%s]", a, b, c), e);
	
##日志定义

推荐下面的定义
	
	private static final Logger logger = LoggerFactory.getLogger(MyClass.class)	
	
如果属于业务日志、其它自定义输出的日志、需要将日志打印至指定日志文件，需要下面的定义

	private static final Logger logger = LoggerFactory.getLogger(“LoggerName");
	
##日志分类

业务日志：
>业务相关的信息.
如：用户操作日志、关键步骤日志、业务逻辑日志.

系统日志
>调试相关的日志，异常信息，用于程序员收集系统健康状况信息。
如：RPC调用日志（请求、响应、耗时）、error日志、改进性日志.

告警日志：
>告警日志
如：连续访问db异常告警、依赖服务调用异常告警.

##建议输出的日志

	info.log: 程序运行过程中的info信息。
	warn.log: 程序内部警告信息.
	error.log: 程序内部运行错误，异常日志
	costtime.log : 调用外部依赖耗时日志.
	alarm.log: 告警日志，程序内部各种场景告警信息输出到这里,告警场景参见 询盘监控需求.ppt
	interface.log: 依赖的外部服务调用过程日志，包括入参，返回值等.